<h1><center>ä»¿çœŸå®éªŒä¸€</center></h1>

<h5><center>2112614 åˆ˜å¿ƒæº</center></h5>

### ä¸€ã€å®éªŒå†…å®¹

æœ¬æ¬¡ä»¿çœŸå®éªŒä¸»è¦ä»»åŠ¡ä¸ºç¼–å†™ä¸€ä¸ªCç¨‹åº`sim.c`ï¼Œè¿™æ˜¯ä¸€ä¸ªé’ˆå¯¹`MIPS`æŒ‡ä»¤é›†çš„æœ‰é™å­é›†çš„æŒ‡ä»¤çº§æ¨¡æ‹Ÿå™¨ï¼Œè¿™ä¸ªæŒ‡ä»¤çº§çš„æ¨¡æ‹Ÿå™¨å°†å¯¹æ¯ä¸ªæŒ‡ä»¤çš„è¡Œä¸ºè¿›è¡Œå»ºæ¨¡å¹¶å…è®¸ç”¨æˆ·è¿è¡Œ`MIPS`ç¨‹åºå¹¶æŸ¥çœ‹å…¶è¾“å‡ºã€‚

æ¨¡æ‹Ÿå™¨å°†å¤„ç†ä¸€ä¸ªåŒ…å«`MIPS`ç¨‹åºçš„è¾“å…¥æ–‡ä»¶ï¼Œè¾“å…¥æ–‡ä»¶çš„æ¯ä¸€è¡Œå¯¹åº”ä¸€ä¸ªå†™å…¥ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸²çš„`MIPS`æŒ‡ä»¤ã€‚æˆ‘ä»¬ç¼–å†™çš„æ¨¡æ‹Ÿå™¨å°†æ‰§è¡Œè¾“å…¥ç¨‹åºï¼Œæ¯æ¬¡åªæ‰§è¡Œä¸€æ¡æŒ‡ä»¤ã€‚åœ¨æ¯æ¡æŒ‡ä»¤ä¹‹åï¼Œæ¨¡æ‹Ÿå™¨å°†ä¿®æ”¹`MIPS`æ¶æ„çŠ¶æ€ï¼ŒåŒ…æ‹¬å­˜å‚¨åœ¨å¯„å­˜å™¨å’Œå†…å­˜ä¸­çš„å€¼ã€‚

æ¨¡æ‹Ÿå™¨åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼š

- shellï¼Œä¸ºç”¨æˆ·æä¾›å‘½ä»¤æ¥æ§åˆ¶æ¨¡æ‹Ÿå™¨çš„æ‰§è¡Œï¼›
- sim.cï¼Œä¹Ÿå°±æ˜¯æ¨¡æ‹Ÿç¨‹åºï¼Œæˆ‘ä»¬å°†è¦å®ç°å®ƒï½



### äºŒã€å®éªŒæ­¥éª¤

#### å°†MIPSæŒ‡ä»¤è½¬æ¢ä¸ºåå…­è¿›åˆ¶æŒ‡ä»¤

ç”±äºæ— æ³•å®‰è£…ä½¿ç”¨åŸæœ‰ä»£ç æ–‡ä»¶ä¸­è‡ªå¸¦çš„`Spim`ğŸ˜­ï¼Œæˆ‘åœ¨å¼€æºå¹³å°ä¸Šæ‰¾åˆ°äº†`mars4.5.jar`è¿›è¡ŒæŒ‡ä»¤è½¬æ¢ï¼Œä½¿ç”¨`python`ç¼–å†™ç›¸åº”çš„è„šæœ¬æ–‡ä»¶åœ¨å‘½ä»¤è¡Œä¸­è°ƒç”¨`jar`åŒ…ï¼Œå°†`.s`æ–‡ä»¶è½¬å˜ä¸º`.x`æ–‡ä»¶å­˜å‚¨ã€‚

```python
#!/usr/bin/python3

import os
import sys

os.system("java -jar Mars4_5.jar " + sys.argv[1] +" dump .text HexText " + sys.argv[1][:-2]+".x")
```

åœ¨`inputs`æ–‡ä»¶å¤¹ä¸‹ä½¿ç”¨å‘½ä»¤æ‰§è¡Œè„šæœ¬æ–‡ä»¶

```bash
./asm2hex addiu.s
```



#### æŒ‡ä»¤å¤„ç†å‡½æ•°ç¼–å†™

##### ç¼–å†™å…¨å±€å˜é‡

```C
char instruction[400]; //å­˜å‚¨è¾“å…¥çš„æŒ‡ä»¤
int curr_pos = 0; //å½“å‰æŒ‡ä»¤çš„ä½ç½®
char conversion[100]; //å­˜å‚¨è½¬æ¢åçš„æŒ‡ä»¤
```



##### ç¼–å†™è¾…åŠ©å‡½æ•°

æ ¹æ®é¢˜æ„ï¼Œéœ€è¦å°†åŸæœ¬çš„åå…­è¿›åˆ¶æŒ‡ä»¤è¿›è¡Œè¯‘ç ï¼Œå› æ­¤ç¼–å†™ä¸€äº›è¾…åŠ©å‡½æ•°å¦‚ä¸‹ï¼š

1. **uintToStr(uin32_t u)**å‡½æ•°

   - `MIPS`æŒ‡ä»¤é€šå¸¸å­˜å‚¨ä¸º32ä½äºŒè¿›åˆ¶æ•°ï¼Œè¯¥å‡½æ•°å°†ä¸€ä¸ª32ä½çš„æ— ç¬¦å·æ•´æ•°ï¼ˆä»£è¡¨æŒ‡ä»¤æˆ–è€…å†…å­˜ä¸­çš„æ•°æ®ï¼‰è½¬æ¢ä¸º32ä½äºŒè¿›åˆ¶å­—ç¬¦ä¸²ï¼Œä»¥ä¾¿äºåç»­çš„è§£æå’Œæ‰§è¡Œã€‚
   - å®ç°æ€è·¯ï¼šå°†è¾“å…¥çš„åå…­è¿›åˆ¶æ•°è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œç”¨å¡«å……æ¯ä¸€ä¸ªå­—ç¬¦ä¸²ç¡®ä¿é•¿åº¦ä¸º8ï¼ˆä¹Ÿå°±æ˜¯ä¿è¯è½¬æ¢ä¸ºäºŒè¿›åˆ¶ä¹‹åä¸º32ä½ï¼‰ï¼›å»ºç«‹æŸ¥æ‰¾è¡¨å°†åå…­è¿›åˆ¶çš„0ï½Fåˆ†åˆ«ä¸äºŒè¿›åˆ¶çš„å­—ç¬¦ä¸²å¯¹åº”ï¼Œéå†å­—ç¬¦ä¸²å°†ä¸€ä½åå…­è¿›åˆ¶å­—ç¬¦è½¬æ¢ä¸º4ä½äºŒè¿›åˆ¶å­—ç¬¦ï¼Œå³å®Œæˆè½¬æ¢ã€‚

   

2. **convertBin(int length)**å‡½æ•°

   - åœ¨è§£ææŒ‡ä»¤æ—¶ï¼Œéœ€è¦ä»äºŒè¿›åˆ¶æŒ‡ä»¤å­—ç¬¦ä¸²ä¸­æå–å„ä¸ªå­—æ®µï¼ˆæ¯”å¦‚æ“ä½œç ï¼Œå¯„å­˜å™¨ç¼–å·ï¼Œæ“ä½œæ•°ç­‰ï¼‰ï¼Œè¯¥å‡½æ•°ä¸­å½“å‰ä½ç½®ï¼ˆå…¨å±€å˜é‡`curr_pos`ï¼‰å¼€å§‹çš„æŒ‡å®šé•¿åº¦ï¼ˆè¾“å…¥å‚æ•°`length`ï¼‰çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°ã€‚
   - å®ç°æ€è·¯ï¼šéå†å­—ç¬¦ä¸²ï¼Œä½¿ç”¨ä½è¿ç®—ç´¯åŠ è®¡ç®—æ•´æ•°ç»“æœã€‚

   

3. **convertChar(char str,int length,int start)**

   - è¯¥å‡½æ•°ç±»ä¼¼äº`convertBin`å‡½æ•°ï¼Œä½†æ˜¯å®ƒå¯ä»¥åœ¨æŒ‡å®šçš„å¼€å§‹ä½ç½®å¯¹äºè¾“å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œè½¬æ¢ã€‚å¯ä»¥ç”¨äºå¤„ç†ä»å†…å­˜ä¸­è¯»å–çš„æ•°æ®ã€‚

   

4. **ComplementToBinary(int length)** 

   - åœ¨å¤„ç†æœ‰ç¬¦å·æ•°ï¼ˆå¦‚ç«‹å³æ•°ã€åç§»é‡ç­‰ï¼‰æ—¶ï¼Œéœ€è¦å°†è¡¥ç å½¢å¼çš„äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°ã€‚

   - å®ç°æ€è·¯ï¼šå°†`instruction`ä¸­çš„äºŒè¿›åˆ¶è¡¥ç å­—ç¬¦ä¸²ï¼ˆä»`curr_pos`å¼€å§‹ï¼Œé•¿åº¦ä¸º`length`ï¼‰è½¬æ¢ä¸ºæ•´æ•°ï¼Œåˆ¤æ–­é¦–ä½ï¼ˆç¬¦å·ä½ï¼‰å¹¶è¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚

   - åç»­çš„**int ComplementToBinaryChar(char\* str, int length)**ä¸å…¶ç±»ä¼¼ï¼Œä½†æ˜¯æ˜¯ä»ç»™å®šå­—ç¬¦ä¸²`str`ä¸­è¯»å–å¹¶è½¬æ¢ã€‚

   - å…¶ä»£ç å¦‚ä¸‹ï¼š

     ```c
     int ComplementToBinary(int length){
         int result = 0;
         if(instruction[curr_pos] == '1'){
             result = convertBin(length) | 0xffff0000;
             //å°†resultçš„å‰16ä½ç¬¦å·æ‰©å±•ä¸º1
             return result;
         }
         result += convertBin(length);
         return result;
     }
     ```



##### ç¼–å†™ä¸»è¦å¤„ç†å‡½æ•°

**process_instruction()**

- è¿™æ˜¯æ¨¡æ‹Ÿå™¨çš„æ ¸å¿ƒå‡½æ•°ï¼Œè´Ÿè´£è¯»å–ã€è§£æå¹¶æ‰§è¡Œä¸€æ¡`MIPS`æŒ‡ä»¤ã€‚é€šè¿‡å€ŸåŠ©ä¸Šè¿°çš„è¾…åŠ©å‡½æ•°æ¥è¯»å–å¹¶è§£ææŒ‡ä»¤ï¼Œç„¶åæ ¹æ®æŒ‡ä»¤çš„ç±»å‹å’Œæ“ä½œç åˆ†åˆ«ç¼–å†™æ‰§è¡Œç›¸åº”çš„æ“ä½œï¼Œå¹¶æ›´æ–°å¯„å­˜å™¨å’Œå†…å­˜çš„çŠ¶æ€ã€‚

- å®ç°å‡†å¤‡ï¼š

  è§‚å¯Ÿæ–‡ä»¶`shell.h`,å‘ç°`NEXT_STATE`å’Œ`CURRENT_STATE`ä¸¤ä¸ªç»“æ„ä½“ä¿å­˜äº†ä¸¤ä¸ªçŠ¶æ€ä¸‹å¯„å­˜å™¨å †çš„çŠ¶å†µã€‚

  ```c
  typedef struct CPU_State_Struct {
  
    uint32_t PC;		/* program counter */
    uint32_t REGS[MIPS_REGS]; /* register file. */
    uint32_t HI, LO;          /* special regs for mult/div. */
  } CPU_State;
  
  /* Data Structure for Latch */
  
  extern CPU_State CURRENT_STATE, NEXT_STATE;
  ```

  åœ¨`shell.c`ä¸­ï¼Œç¼–å†™äº†`cycle()`å‡½æ•°ï¼Œå®Œæˆå°†ä¸‹ä¸€ä¸ªçŠ¶æ€èµ‹å€¼ç»™å½“å‰çŠ¶æ€ã€‚

  ```c
  void cycle() {                                                
    process_instruction();
    CURRENT_STATE = NEXT_STATE;
    INSTRUCTION_COUNT++;
  }
  ```

  åœ¨`process_instruction()`å‡½æ•°æ‰§è¡Œæ—¶åªéœ€è¦å°†`NEXT_STATE`çš„`PC`+4å³å¯ã€‚

- å®ç°æ€è·¯ï¼š

  - è¯»å–å½“å‰`PC`æŒ‡å‘çš„æŒ‡ä»¤ï¼Œå¹¶è½¬æ¢ä¸ºäºŒè¿›åˆ¶å­—ç¬¦ä¸²å­˜å‚¨åœ¨`instruction`ä¸­ï¼›

  - æ£€æµ‹è¯¥æŒ‡ä»¤æ˜¯å¦ä¸º`syscall`

    ```c
    if(convertBin(32) == 12){
      if(NEXT_STATE.REGS[2] == 10){
        RUN_BIT = 0;
        return;
      }
    }
    ```

    æ ¹æ®å®éªŒæŒ‡å¯¼ä¸­æåˆ°çš„

    > if the register  `$v0`  (register 2) has value ` 0x0A`  (decimal 10) when `SYSCALL` is executed, then the  `go`  command should stop its simulation loop and return to the simulator shellâ€™s prompt. If  `$v0` has any other value, the instruction should have no effect.
    >
    > The  `process_instruction()`  function that you write should cause the main simulation loop to terminate by setting the global variable ` RUN_BIT`  to 0

    æ ¹æ®é¢˜ç›®è¦æ±‚æ£€æµ‹å¯„å­˜å™¨`$v0`çš„å€¼ï¼Œå¦‚æœæ˜¯`0x0A`åˆ™å°†`RUN_BIT`ç½®ä¸º0å¹¶è¿”å›ï¼›

  - ä½¿ç”¨`convertBin`å‡½æ•°å–å‡º`type`å­—æ®µåˆ†è¾¨æŒ‡ä»¤ç±»å‹

    1.***Rå‹æŒ‡ä»¤***

    ç”±äºç¯‡å¹…é™åˆ¶ï¼Œé€‰å–Rå‹æŒ‡ä»¤ä¸­çš„å‡ ä¸ªè¿›è¡Œåˆ†æã€‚å…¶ä½™æŒ‡ä»¤ä¸å…¶ç±»ä¼¼ï½

    ```C
    switch (funct)
    {
      case 32:
        //add
        printf("instruction ADD $%d $%d $%d executed\n", rd, rs, rt);
        NEXT_STATE.REGS[rd] = CURRENT_STATE.REGS[rs] + CURRENT_STATE.REGS[rt];
        break;
    
      case 0:
        //sll
        printf("instruction SLL $%d $%d %d executed\n", rd, rt, shamt);
        NEXT_STATE.REGS[rd] = CURRENT_STATE.REGS[rt] << shamt;
        break;
    
      case 3:
        // sra
        printf("instruction SRA $%d $%d %d executed\n", rd, rt, shamt);
        uint32_t result = CURRENT_STATE.REGS[rt] >> shamt;
        // æ£€æŸ¥åŸå¯„å­˜å™¨ä¸­æ•°æ®æœ€é«˜ä½æ˜¯å¦ä¸º1
        if (CURRENT_STATE.REGS[rt] & 0x80000000) {
          // æ„å»ºä¸€ä¸ªæ©ç ï¼Œå°†resultå·¦è¾¹çš„shamtä¸ªä½ç½®1ï¼Œè€Œåé¢çš„ä½ä¿æŒä¸å˜
          uint32_t mask = (1U << (32 - shamt)) - 1;
          result = result | (~mask);
        }
        NEXT_STATE.REGS[rd] = result;
    
      case 9:
        // jalr
        printf("instruction JALR $%d $%d executed\n", rd, rs);
        NEXT_STATE.REGS[rd] = CURRENT_STATE.PC;
        NEXT_STATE.PC = CURRENT_STATE.REGS[rs] - 4;
    
      case 16:
        //mfhi
        printf("instruction MFHI $%d executed\n", rd);
        NEXT_STATE.REGS[rd] = CURRENT_STATE.HI;
        
      case 24:
        //mult
        printf("instruction MULT $%d $%d executed\n", rs, rt);
        int64_t result2 = (int64_t)CURRENT_STATE.REGS[rs] * (int64_t)CURRENT_STATE.REGS[rt];
        CURRENT_STATE.HI = result2 >> 32;
        CURRENT_STATE.LO = result2 & 0xffffffff;
        printf("HI: 0x%08X\n", CURRENT_STATE.HI);
        printf("LO: 0x%08X\n", CURRENT_STATE.LO);
    
      case 42:
        //slt   
        printf("instruction SLT $%d $%d $%d executed\n", rd, rs, rt);
        if ((int32_t)CURRENT_STATE.REGS[rs] < (int32_t)CURRENT_STATE.REGS[rt]) {
          NEXT_STATE.REGS[rd] = 1;
        } 
        else {
          NEXT_STATE.REGS[rd] = 0;
        }
    
        break;
      default:
        break;
    }
    ```

    `ADD`æŒ‡ä»¤ï¼šè¯¥æŒ‡ä»¤å°†å½“å‰çŠ¶æ€ä¸­`rs`å’Œ`rt`å¯„å­˜å™¨é‡Œçš„æ•°å€¼è¿›è¡Œç›¸åŠ ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°ä¸‹ä¸€çŠ¶æ€çš„`rd`å¯„å­˜å™¨ä¸­ï¼›å…¶ä½™ç±»ä¼¼æŒ‡ä»¤å¦‚`SUB`,`AND`,`OR`ç­‰ä¹Ÿæ˜¯è¿™æ ·ï¼›

    

    `SLL`æŒ‡ä»¤ï¼šé€»è¾‘å·¦ç§»æŒ‡ä»¤ï¼Œé€šè¿‡ä½¿ç”¨ä½è¿ç®—ç¬¦å·`<<`ï¼Œè¯¥æŒ‡ä»¤å°†å½“å‰çŠ¶æ€ä¸‹çš„`rt`å¯„å­˜å™¨ä¸­çš„æ•°æ®å·¦ç§»`shamt`ä½ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°ä¸‹ä¸€çŠ¶æ€çš„`rd`å¯„å­˜å™¨ä¸­ï¼›

    

    `SRA`æŒ‡ä»¤ï¼šç®—æœ¯å³ç§»æŒ‡ä»¤ï¼Œé¦–å…ˆå¯¹`CURRENT_STATE.REGS[rt]`æ‰§è¡Œé€»è¾‘å³ç§»ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨`result`ä¸­ã€‚æ£€æŸ¥åŸå¯„å­˜å™¨ä¸­æ•°æ®çš„æœ€é«˜ä½ï¼ˆç¬¦å·ä½ï¼‰æ˜¯å¦ä¸º1ï¼Œå¦‚æœæ˜¯ï¼Œé€šè¿‡ä¸€ä¸ªæ©ç å°†`result`çš„å·¦è¾¹çš„`shamt`ä¸ªä½ç½®1ï¼Œè€Œåé¢çš„ä½ä¿æŒä¸å˜ï¼Œæœ€åå°†å¤„ç†åçš„`result`èµ‹å€¼ç»™ä¸‹ä¸€ä¸ªçŠ¶æ€çš„`rd`å¯„å­˜å™¨ã€‚

    

    `SLT`æŒ‡ä»¤ï¼šæ¯”è¾ƒ`CURRENT_STATE.REGS[rs]`å’Œ`CURRENT_STATE.REGS[rt]`ï¼Œå¦‚æœå‰è€…æ•°å€¼å°äºåè€…

    ï¼Œåˆ™ç›®æ ‡å¯„å­˜å™¨`rd`è¢«è®¾ç½®ä¸º1ï¼Œå¦åˆ™è®¾ç½®ä¸º0ã€‚`SLTU`æŒ‡ä»¤ä¸å…¶ç±»ä¼¼ã€‚

    

    `JALR`æŒ‡ä»¤ï¼šè·³è½¬é“¾æ¥æŒ‡ä»¤ï¼Œå¸¸ç”¨äºå‡½æ•°è°ƒç”¨ã€‚å°†å½“å‰çŠ¶æ€ï¼ˆ`CURRENT_STATE`ï¼‰çš„ç¨‹åºè®¡æ•°å™¨ï¼ˆ`PC`ï¼Œä»£è¡¨å½“å‰æŒ‡ä»¤åœ°å€ï¼‰çš„å€¼ä¿å­˜åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€ï¼ˆ`NEXT_STATE`ï¼‰çš„ç›®çš„å¯„å­˜å™¨ï¼ˆ`REGS[rd]`ï¼‰ä¸­ã€‚è¿™é€šå¸¸ç”¨äºä¿å­˜è¿”å›åœ°å€ã€‚

    

    `MFHI`æŒ‡ä»¤ï¼šå°†`HI`å¯„å­˜å™¨çš„å†…å®¹å¤åˆ¶åˆ°ä¸€ä¸ªæ™®é€šçš„å¯„å­˜å™¨ä¸­ã€‚å°†å½“å‰çŠ¶æ€ï¼ˆ`CURRENT_STATE`ï¼‰çš„HIå¯„å­˜å™¨çš„å€¼å¤åˆ¶åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€ï¼ˆ`NEXT_STATE`ï¼‰çš„ç›®çš„å¯„å­˜å™¨ï¼ˆ`REGS[rd]`ï¼‰ä¸­ã€‚

    

    `MULT`æŒ‡ä»¤ï¼šæŒ‡ä»¤ç”¨äºå°†ä¸¤ä¸ªå¯„å­˜å™¨ä¸­çš„æ•°å€¼ç›¸ä¹˜ï¼Œå¹¶å°†64ä½çš„ç»“æœå­˜å‚¨åˆ°ä¸¤ä¸ªç‰¹æ®Šçš„å¯„å­˜å™¨ï¼š`HI` å¯„å­˜å™¨å’Œ `LO` å¯„å­˜å™¨ã€‚è®¡ç®—æºå¯„å­˜å™¨ `rs` å’Œ `rt` ä¸­çš„å€¼çš„ä¹˜ç§¯ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨64ä½æ•´æ•° `result2` ä¸­ã€‚å°† `result2` çš„é«˜32ä½å­˜å‚¨åˆ° `HI` å¯„å­˜å™¨ä¸­ï¼Œä½32ä½å­˜å‚¨åˆ° `LO` å¯„å­˜å™¨ä¸­ã€‚`&` æ˜¯ä½ä¸æ“ä½œç¬¦ï¼Œ`result2 & 0xffffffff` è¡¨ç¤ºå– `result2` çš„ä½32ä½ã€‚

    

    2.***Jå‹æŒ‡ä»¤***

    ```C
        else if(InstructionType == 2 || InstructionType == 3)
        {
            //Jå‹æŒ‡ä»¤
            int address = convertBin(26) * 4; 
          	//åœ°å€ï¼Œç”±äºMIPSæ˜¯åŸºäºå­—çš„ï¼Œåœ°å€ä¸ºå­—å¯¹é½ï¼Œå› æ­¤*4
            switch (InstructionType)
            {
            case 2:
                //j
                printf("instruction J %d executed\n", address);
                NEXT_STATE.PC =(uint32_t) address - 4;
                break;
            
            case 3:
                //jal
                printf("instruction JAL %d executed\n", address);
                NEXT_STATE.REGS[31] = CURRENT_STATE.PC;
                NEXT_STATE.PC = address - 4;
                break;
            
            default:
                break;
            }
        }
    ```

    `J`æŒ‡ä»¤ï¼šæ— æ¡ä»¶è·³è½¬ã€‚æ‰§è¡Œæ­¤æŒ‡ä»¤æ—¶ï¼Œå°†`address`ç›´æ¥èµ‹å€¼ç»™ä¸‹ä¸€ä¸ªçŠ¶æ€çš„`PC`å¯„å­˜å™¨ã€‚ç”±äºåœ¨æ‰§è¡Œæ¯æ¡æŒ‡ä»¤åï¼Œ`PC`ä¼šè‡ªåŠ¨å¢åŠ 4ï¼Œä»¥æŒ‡å‘ä¸‹ä¸€æ¡è¦æ‰§è¡Œçš„æŒ‡ä»¤ï¼Œå› æ­¤å®é™…å®ç°ä¸­æˆ‘ä»¬å°†`address - 4`èµ‹å€¼ç»™`NEXT_STATE.PC`ï¼Œä»¥ç¡®ä¿è·³è½¬åœ°å€çš„æ­£ç¡®æ€§ã€‚

    

    `JAL`æŒ‡ä»¤ï¼š`JAL`æŒ‡ä»¤ï¼ˆè·³è½¬å¹¶é“¾æ¥ï¼‰ä¸`J`æŒ‡ä»¤ç±»ä¼¼ï¼Œä¹Ÿç”¨äºæ— æ¡ä»¶è·³è½¬ï¼Œä½†åŒæ—¶è¿˜ä¼šå°†è·³è½¬å‰çš„ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ï¼ˆå³`CURRENT_STATE.PC + 4`ï¼‰ä¿å­˜åˆ°`$ra`å¯„å­˜å™¨ä¸­ã€‚è¿™æ ·åšçš„ç›®çš„æ˜¯ï¼Œå½“å‡½æ•°æˆ–å­ç¨‹åºæ‰§è¡Œå®Œæ¯•åï¼Œå¯ä»¥é€šè¿‡å¯„å­˜å™¨`$ra`ä¸­ä¿å­˜çš„åœ°å€è¿”å›åˆ°è°ƒç”¨ä½ç½®ï¼Œç»§ç»­æ‰§è¡Œåç»­çš„æŒ‡ä»¤ã€‚

    

    3.***Iå‹æŒ‡ä»¤***

    ```c
    case 1:
        //bltz
        printf("%d",NEXT_STATE.REGS[rs]);
        if(rt == 0){
          //bltz
          immediate = ComplementToBinary(16);
          if(NEXT_STATE.REGS[rs] & 0x80000000){
            NEXT_STATE.PC += immediate * 4 ;
          }
          printf("instruction BLTZ $%d %d executed\n", rs, immediate);
        }
        else if(rt == 1){
          //bgez
          immediate = ComplementToBinary(16);
          if(!(NEXT_STATE.REGS[rs] & 0x80000000) ){
            NEXT_STATE.PC += immediate * 4;
          }
          printf("instruction BGEZ $%d %d executed\n", rs, immediate);
        }
        else if(rt == 16){
          //bltzal
          immediate = ComplementToBinary(16);
          printf("%s %u","rs val:",NEXT_STATE.REGS[rs]);
          if(NEXT_STATE.REGS[rs] & 0x80000000){
    
            NEXT_STATE.REGS[31] = CURRENT_STATE.PC;
            NEXT_STATE.PC += immediate<<2 ;
          }
          printf("instruction BLTZAL $%d %d executed\n", rs, immediate);
        }
        else if(rt == 17){
          //bgezal
          immediate = ComplementToBinary(16);
          printf("%s %u","rs val:",NEXT_STATE.REGS[rs]);
          if( !(NEXT_STATE.REGS[rs] & 0x80000000) ){
            NEXT_STATE.REGS[31] = CURRENT_STATE.PC;
            NEXT_STATE.PC += immediate<<2 ;
          }
          printf("instruction BGEZAL $%d %d executed\n", rs, immediate);
        }
    case 4:
        //beq
        immediate = ComplementToBinary(16);
        if(NEXT_STATE.REGS[rs] == CURRENT_STATE.REGS[rt]){
          NEXT_STATE.PC += immediate * 4;
        }
        printf("instruction BEQ $%d $%d %d executed\n", rs, rt, immediate);
    
    case 33:
        //lh
        immediate = ComplementToBinary(16);
        uintToStr(mem_read_32(CURRENT_STATE.REGS[rs] + immediate));
        strncpy(subbuff, conversion, 16);
        NEXT_STATE.REGS[rt] = ComplementToBinaryChar(subbuff,16); //å°†è½¬æ¢åçš„æŒ‡ä»¤å­˜å…¥instructionä¸­
        printf("instruction LH $%d (%d) $%d executed\n", rt, immediate,rs); 
        break;
    
    case 41:
        //sh
        immediate = ComplementToBinary(16);
        uintToStr(NEXT_STATE.REGS[rt]);
        strncpy(subbuff, conversion, 16);
        mem_write_32(CURRENT_STATE.REGS[rs] + immediate,ComplementToBinaryChar(subbuff,16));
        printf("instruction SH $%d (%d) $%d executed\n", rt, immediate,rs);
    ```

    åŒæ ·ç”±äºå—ç¯‡å¹…é™åˆ¶ï¼Œé€‰å–å‡ ä¸ªRå‹æŒ‡ä»¤è¿›è¡Œåˆ†æ

    `BTLZ`&`BTLZAL`æŒ‡ä»¤ï¼šæ³¨æ„åˆ°å…¶å®`BTLZ`&`BTLZAL`&`BGEZ`&`BGEZAL`è¿™å››ä¸ªæŒ‡ä»¤çš„`option`æ“ä½œç å…¶å®éƒ½æ˜¯000001ï¼Œæ‰€ä»¥éœ€è¦é€šè¿‡`rt`å­—æ®µæ¥è¿›è¡ŒåŒºåˆ†ã€‚

    - `BLTZAL`çš„`rt`å­—æ®µå€¼ä¸º`10001`ï¼ˆåè¿›åˆ¶çš„17ï¼‰
    - `BGEZAL`çš„`rt`å­—æ®µå€¼ä¸º`10000`ï¼ˆåè¿›åˆ¶çš„16ï¼‰
    -  `BLTZ` æŒ‡ä»¤ï¼Œ`rt` å­—æ®µçš„å€¼ä¸º `00000`ï¼ˆåè¿›åˆ¶ä¸­çš„ 0ï¼‰ã€‚
    -  `BGEZ` æŒ‡ä»¤ï¼Œ`rt` å­—æ®µçš„å€¼ä¸º `00001`ï¼ˆåè¿›åˆ¶ä¸­çš„ 1ï¼‰ã€‚

    

    è¿™å‡ ä¸ªæŒ‡ä»¤è¾ƒä¸ºç±»ä¼¼ï¼Œé€‰å–**BLTZAL**è¿›è¡Œè§£é‡Šï¼šè¿™ä¸ªæŒ‡ä»¤ç”¨äºæµ‹è¯•ä¸€ä¸ªå¯„å­˜å™¨ä¸­çš„å€¼æ˜¯å¦å°äºé›¶ã€‚å¦‚æœæ˜¯ï¼Œåˆ™è·³è½¬åˆ°ç›®æ ‡åœ°å€ï¼Œå¹¶ä¸”å°†è¿”å›åœ°å€ï¼ˆå½“å‰æŒ‡ä»¤åœ°å€åŠ 4ï¼‰å­˜å‚¨åˆ°é“¾æ¥å¯„å­˜å™¨ `$ra` ä¸­ã€‚ä¹Ÿå°±æ˜¯å¦‚æœå¯„å­˜å™¨ `rs` ä¸­çš„å€¼å°äº0ï¼Œåˆ™ç¨‹åºå°†è·³è½¬åˆ° `PC + offset * 4`çš„åœ°å€ï¼Œå…¶ä¸­ `PC` æ˜¯å½“å‰æŒ‡ä»¤çš„åœ°å€ã€‚æ³¨æ„åˆ°ç”±äºå¯„å­˜å™¨ä¸­å­˜å‚¨çš„æ˜¯**æ— ç¬¦å·æ•´å‹**ï¼Œä¹Ÿå°±æ˜¯ç›´æ¥ä½¿ç”¨`NEXT_STATE.REGS[rs]`æ˜¯ä¼šè¢«ç¿»è¯‘ä¸ºæ­£æ•°ï¼Œé‚£ä¹ˆä¸å¯èƒ½è¿›è¡Œè·³è½¬ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦åŠ ä¸Šä¸€ä¸ªåˆ¤æ–­ï¼š`NEXT_STATE.REGS[rs] & 0x80000000`ï¼Œè¿™æ¡è¯­å¥å¯ä»¥å¯¹äº`NEXT_STATE.REGS[rs]`çš„æœ€é«˜ä½è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœæœ€é«˜ä½æ˜¯1åˆ™ç»“æœä¸º1ï¼Œä¹Ÿå°±æ˜¯è¯¥æ•°æ˜¯è´Ÿæ•°ï¼Œè¿›è¡Œè·³è½¬ã€‚

    

    `beq`æŒ‡ä»¤ï¼šæ¯”è¾ƒä¸¤ä¸ªå¯„å­˜å™¨ä¸­çš„å€¼ï¼Œå¦‚æœç›¸ç­‰ï¼Œåˆ™ç¨‹åºè®¡æ•°å™¨ï¼ˆPCï¼‰ä¼šè·³è½¬åˆ°æŸä¸ªæ–°çš„åœ°å€ï¼Œå®ç°åˆ†æ”¯ã€‚æ¯”è¾ƒä¸¤ä¸ªå¯„å­˜å™¨ `rs` å’Œ `rt` ä¸­çš„å€¼ã€‚å¦‚æœ `rs` å’Œ `rt` å¯„å­˜å™¨ä¸­çš„å€¼ç›¸ç­‰ï¼Œé‚£ä¹ˆç¨‹åºè®¡æ•°å™¨ï¼ˆPCï¼‰çš„å€¼ä¼šå¢åŠ  `immediate * 4`ã€‚è¿™é‡Œ `* 4` æ˜¯å› ä¸º MIPS æŒ‡ä»¤é›†ä¸­çš„åœ°å€æ˜¯ä»¥å­—èŠ‚ä¸ºå•ä½çš„ï¼Œè€Œæ¯æ¡æŒ‡ä»¤çš„é•¿åº¦æ˜¯ 4 å­—èŠ‚ï¼Œæ‰€ä»¥éœ€è¦ä¹˜ä»¥ 4ã€‚

    

    `lh`æŒ‡ä»¤ï¼šç”¨äºä»å†…å­˜ä¸­åŠ è½½ä¸€ä¸ªåŠå­—ï¼ˆ16ä½ï¼‰åˆ°ä¸€ä¸ªå¯„å­˜å™¨ä¸­ã€‚é€šè¿‡`CURRENT_STATE.REGS[rs] + immediate`è®¡ç®—å‡ºè¦è¯»å–çš„å†…å­˜åœ°å€ã€‚ç„¶åï¼Œè°ƒç”¨`mem_read_32`å‡½æ•°ä»è¯¥åœ°å€è¯»å–32ä½ï¼ˆ4å­—èŠ‚ï¼‰çš„æ•°æ®ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²æ ¼å¼ã€‚ä½¿ç”¨`strncpy`å‡½æ•°å°†`conversion`å­—ç¬¦ä¸²çš„å‰16ä¸ªå­—ç¬¦å¤åˆ¶åˆ°`subbuff`å­—ç¬¦ä¸²ä¸­å°†`subbuff`å­—ç¬¦ä¸²è½¬æ¢ä¸ºäºŒè¿›åˆ¶æ•°ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨`NEXT_STATE.REGS[rt]`å¯„å­˜å™¨ä¸­ï¼Œæ¨¡æ‹Ÿ`LH`æŒ‡ä»¤å°†æ•°æ®ä»å†…å­˜åŠ è½½åˆ°å¯„å­˜å™¨ã€‚

    

    `sh`æŒ‡ä»¤ï¼šç”¨äºå°†å¯„å­˜å™¨ä¸­çš„ä¸€ä¸ªåŠå­—ï¼ˆ16 ä½ï¼‰æ•°æ®å­˜å‚¨åˆ°å†…å­˜ä¸­ã€‚å°† `NEXT_STATE.REGS[rt]` ä¸­çš„å€¼è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå°† `conversion` å­—ç¬¦ä¸²çš„å‰ 16 ä¸ªå­—ç¬¦å¤åˆ¶åˆ° `subbuff` å­—ç¬¦ä¸²ä¸­ã€‚è®¡ç®—å†…å­˜åœ°å€ `CURRENT_STATE.REGS[rs] + immediate`ï¼Œç„¶åè°ƒç”¨ `ComplementToBinaryChar` å‡½æ•°å°† `subbuff` è½¬æ¢ä¸ºäºŒè¿›åˆ¶æ•°ï¼Œå¹¶å°†è¯¥å€¼å†™å…¥è®¡ç®—å‡ºçš„å†…å­˜åœ°å€ã€‚æ¨¡æ‹Ÿ `SH` æŒ‡ä»¤å°†å¯„å­˜å™¨ä¸­çš„æ•°æ®å­˜å‚¨åˆ°å†…å­˜ã€‚



#### ç¼–è¯‘æµ‹è¯•

ä½¿ç”¨æŒ‡ä»¤`src/sim inputs/brtest2.x`æ‰“å¼€æ¨¡æ‹Ÿå™¨ï¼Œç”¨`betest2.x`ä½œä¸ºæµ‹è¯•ä»£ç å¾—åˆ°è¾“å‡ºå¦‚ä¸‹ï¼š

```bash
MIPS Simulator

Read 11 words from program into memory.

MIPS-SIM> go

Simulating...

00100100000000100000000000001010
instruction ADDIU $2 $0 10 executed

00001000000100000000000000000010
instruction J 4194312 executed

00010100000000000000000000000011
instruction BNE $0 $0 3 executed

00010000000000000000000000000011
instruction BEQ $0 $0 3 executed

00111100000000010000000000000000
instruction LUI $1 0 executed

00110100001000011101000000001101
instruction ORI $1 $1 53261 executed

00000000000000010011100000100001
instruction ADDU $7 $0 $1 executed

00000000000000000000000000001100
Simulator halted
```

PSï¼šå‘ç°ä¼¼ä¹MARSåœ¨å°†MIPSè½¬æ¢ä¸ºæœºå™¨ç çš„æ—¶å€™ä¼¼ä¹ä¼šå°†`addiu`æŒ‡ä»¤åˆ†ä¸ºå¤šæ¡æŒ‡ä»¤è¿›è¡Œæ‰§è¡Œã€‚æ¯”å¦‚æœ¬ä»£ç åŸæœ¬åœ¨`BEQ $0 $0 3`ä¹‹ååº”å½“æ˜¯`addiu $7, $zero, 0xd00d`ï¼Œä½†æ˜¯MARSå°†è¿™ä¸ªæŒ‡ä»¤åˆ†ä¸ºä¸‰æ¡ï¼š`LUI $1 0`,`ORI $1 $1 53261(0x0000d00d)`,`ADDU $7 $0 $1`è¿›è¡Œå®ç°ã€‚ä½†æ˜¯ç»“æœä¹Ÿæ˜¯æ­£ç¡®çš„ã€‚

å‘ç°ç”±äº`addiu`æ˜¯æ— ç¬¦å·æ•´å‹åŠ æ³•ï¼Œä½†æ˜¯`0xd00d`æ˜¯è´Ÿæ•°ï¼Œå› æ­¤å¯èƒ½MARSä¼šå¯¹äºè¿™ç§æŒ‡ä»¤è¿›è¡Œä¼˜åŒ–ï¼Œä»è€Œè¿›è¡Œç¬¦å·æ‰©å±•ä¹‹ååœ¨è¿›è¡ŒåŠ æ³•ã€‚



